---
/**
 * InteractiveSkillIcon - A skill icon with bounce and tilt effects
 * Features:
 * - Bounce on hover
 * - Slight tilt toward cursor
 * - Glow pulse on hover
 * - Random idle nudge animation
 */
import SkillIcon from './SkillIcon.astro';

interface Props {
  icon: string;
  name: string;
  class?: string;
  'data-reveal-delay'?: number;
}

const { icon, name, class: className, 'data-reveal-delay': revealDelay } = Astro.props;
---

<div class:list={['skill-icon-wrapper', className]} data-skill-icon data-reveal-delay={revealDelay}>
  <div class="skill-icon-container">
    <div class="flex h-16 w-16 items-center justify-center rounded-xl bg-[#1a1a2e] border border-teal-400/30 shadow-[0_0_15px_rgba(45,212,191,0.1)] skill-icon-box">
      <SkillIcon icon={icon} name={name} />
    </div>
  </div>
  <span class="text-xs text-[#A0A0B0] mt-1 block text-center leading-tight max-w-16">
    {name}
  </span>
</div>

<style>
  .skill-icon-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .skill-icon-container {
    perspective: 500px;
  }

  .skill-icon-box {
    transform-style: preserve-3d;
    transform: rotateX(var(--rotate-x, 0deg)) rotateY(var(--rotate-y, 0deg)) translateY(var(--bounce-y, 0px));
    transition:
      transform 0.2s cubic-bezier(0.22, 1, 0.36, 1),
      box-shadow 0.3s ease,
      border-color 0.3s ease;
    will-change: transform;
  }

  .skill-icon-wrapper:hover .skill-icon-box {
    border-color: rgba(45, 212, 191, 0.5);
    box-shadow: 0 0 25px rgba(45, 212, 191, 0.2);
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .skill-icon-box {
      transform: none !important;
      transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }
  }
</style>

<script>
  import { lerp, prefersReducedMotion, initInteractiveComponent, sharedAnimationLoop } from '../scripts/whimsy-utils';
  import { TILT, MOVEMENT, LERP, THRESHOLD } from '../scripts/animation-config';

  function initSkillIcons() {
    if (prefersReducedMotion()) return;

    const icons = document.querySelectorAll('[data-skill-icon]');

    icons.forEach((wrapper, index) => {
      const box = wrapper.querySelector('.skill-icon-box') as HTMLElement;
      if (!box) return;

      initInteractiveComponent(`skill-icon-${index}`, {
        onInit: (signal) => {
          let currentRotateX = 0;
          let currentRotateY = 0;
          let currentBounceY = 0;
          let targetRotateX = 0;
          let targetRotateY = 0;
          let targetBounceY = 0;
          let isHovering = false;
          let isAnimating = false;

          // Cache rect to avoid layout thrashing
          let cachedRect: DOMRect | null = null;

          function updateRect() {
            cachedRect = box.getBoundingClientRect();
          }

          function animate(): boolean {
            currentRotateX = lerp(currentRotateX, targetRotateX, LERP.medium);
            currentRotateY = lerp(currentRotateY, targetRotateY, LERP.medium);
            currentBounceY = lerp(currentBounceY, targetBounceY, LERP.fast);

            box.style.setProperty('--rotate-x', `${currentRotateX}deg`);
            box.style.setProperty('--rotate-y', `${currentRotateY}deg`);
            box.style.setProperty('--bounce-y', `${currentBounceY}px`);

            const settled =
              Math.abs(currentRotateX - targetRotateX) < THRESHOLD.rotation &&
              Math.abs(currentRotateY - targetRotateY) < THRESHOLD.rotation &&
              Math.abs(currentBounceY - targetBounceY) < THRESHOLD.position;

            if (settled) {
              isAnimating = false;
              return false; // Unsubscribe from loop
            }
            return true; // Continue animating
          }

          function startAnimation() {
            if (!isAnimating) {
              isAnimating = true;
              sharedAnimationLoop.subscribe(animate);
            }
          }

          function handleMouseMove(e: MouseEvent) {
            if (!isHovering || !cachedRect) return;

            const centerX = cachedRect.left + cachedRect.width / 2;
            const centerY = cachedRect.top + cachedRect.height / 2;

            const normalizedX = (e.clientX - centerX) / (cachedRect.width / 2);
            const normalizedY = (e.clientY - centerY) / (cachedRect.height / 2);

            targetRotateY = normalizedX * TILT.skillIcon;
            targetRotateX = -normalizedY * TILT.skillIcon;

            startAnimation();
          }

          function handleMouseEnter() {
            isHovering = true;
            updateRect();
            targetBounceY = MOVEMENT.skillBounce;
            startAnimation();
          }

          function handleMouseLeave() {
            isHovering = false;
            cachedRect = null;
            targetRotateX = 0;
            targetRotateY = 0;
            targetBounceY = 0;
            startAnimation();
          }

          (wrapper as HTMLElement).addEventListener('mouseenter', handleMouseEnter, { signal });
          (wrapper as HTMLElement).addEventListener('mouseleave', handleMouseLeave, { signal });
          (wrapper as HTMLElement).addEventListener('mousemove', handleMouseMove, { signal });
        },
      });
    });
  }

  // Initialize
  initSkillIcons();

  // Re-initialize after view transitions
  document.addEventListener('astro:after-swap', initSkillIcons);
</script>
